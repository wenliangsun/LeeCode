# 笔试题总结

## 腾讯

### 1. 打怪兽游戏

小Q在玩一款打怪兽的游戏，他在之前的关卡已经获得了足够多的金币，当前关有n个怪兽，每个怪兽有$C_i$的血量，打死它可以获得$W_i$的金币， 问小Q通过当前关卡最多可以多获得多少金币。

输入：

输入两个数，n,m 。n表示怪兽的数量，m表示一个金币可以购买的血量

接下来n行，每行是一个怪兽的血量和打死它可以获得的金币。

输出：

通过当前关卡最多可以多获得的金币数

#### 参考代码

```C++
#include <iostream>

using namespace std;

const int N = 1010;

int c[N], w[N];

int main() {
    int n, m;
    while (cin >> n >> m) {
        for (int i = 0; i < n; i++) {
            cin >> c[i] >> w[i];
        }
        int cost = 0;   // 记录买血花了多少钱
        int blood = 0;  // 记录自己拥有的血量
        int gain = 0;   // 记录打怪兽获得的金币
        // 遍历每一只怪兽，可以选择打或者不打
        for (int i = 0; i < n; i++) {
            // 先购买可以打死当前怪兽的血量
            int cnt = 0;
            while (blood < c[i]) {
                cnt++;
                blood += m;
            }
            //如果买血花的金币小于等于打死获得的金币，说明值得打
            if (cnt - w[i] <= 0) {
                cost += cnt;
                blood -= c[i];
                gain += w[i];
                // 否则选择不打
            } else {
                blood -= cnt * m;
            }
        }
        cout << gain - cost << endl;
    }
    return 0;
}
```

### 2.  抛物线与直线围成的面积

求抛物线和直线围成的面积

#### 参考代码

```c++
#include <iostream>

using namespace std;

int main() {
	// 待填

    return 0;
}
```

### 3. 牢房冲突

有n个牢房，编号为1\~n,每个牢房中都包含一个人，每个人都可以在1\~m中选择一个数字，如果有相邻牢房选择的数字相同，则会发生冲突。求发生冲突的情况有多少种？结果取mod100003.

输入： m ，n

输出： 发生冲突的情况数。

#### 参考代码

```c++
#include <iostream>

using namespace std;

const int mod = 100003;

int main(){
    // 待填
    
    
    return 0;
}
```

### 4. 完美数

有n个数，每个数有k个属性值，对于任意的两个数$a_i$和$a_j$，如果 $a_{i1}$+$a_{j1} $= $a_{i2}$+$a_{j2}$ = ...=$a_{ik}$+$a_{jk}$,则成$a_i$和$a_j$是一对完美数。 求这n个数中总共有多少对完美数.

输入：
n, k 。n个数，每个数有k个属性。

接下来n行，每行k个属性

输出：

总共有多少对完美数

#### 参考代码

```c++
#include <iostream>
#include <vector>

using namespace std;

int main() {
	// 待填
    
    return 0;
}
```

### 5. 最大关系网

有n对关系，比如A和B有关系，B和C有关系，则ABC有关系。求这些关系中能构成的最大关系网中的人数。

输入：

n 。n对关系

接下来n行，每行是一对关系

输出：

这些关系中构建出来的最大关系网中的人数

#### 参考代码

```c++
#include <iostream>

using namespace std;

int main(){
    // 待填
    
    return 0;
}
```

## 阿里

### 1. 翻转01串

给你一串01组成的字符串，可以选择一个位置进行翻转，即0变1,1变0，同时与该位置相邻的位置也要进行翻转 如 11011 在0的位置翻转变为10101，问给定一个这样的串，最少经过多少次翻转可以变成全0串，如果变不成输出NO。
样例：
"01" --> NO
"011" --> 1

#### 参考代码

``` c++
#include <iostream>
#include <string>
#include <vector>

using namespace std;

/**
 * 思路：每一个位置要么不翻转，要么只翻转一次，翻转两次相当于没翻转
 * 然后深度优先搜索。
 * LeeCode1284
 */

class Solution {
   public:
    int reverse(string s) {
        if (s == "1") {
            return 1;
        } else if (s == "0") {
            return 0;
        }
        int count = 0;
        if (helper(s, 0, 0)) {
            return res;
        } else {
            return -1;
        }
    }

   private:
    int res = 0;  // 记录翻转次数
    bool helper(string s, int index, int count) {
        string temp(s.size(), '0');  // 和s等长的全0串
        if (s == temp) {  // 如果等于全0串，则记录翻转次数，返回
            res = count;
            return true;
        }
        // 如果翻转的位置已经到达s的末尾，则不能翻转成全0串
        if (index == s.size()) {
            return false;
        }
        // 递归，要么翻转当前位置，要么不翻转当前位置
        // 翻转当前位置 调用reverse函数翻转，计数器count+1，并移动到下一个位置
        // 若不翻转，移到下一个位置，
        return helper(reverse(s, index), index + 1, count + 1) ||
               helper(s, index + 1, count);
    }

    // 翻转字符串中的每一个位置，注意边界情况
    string reverse(string s, int index) {
        int n = s.size() - 1;
        if (index == 0) {
            s[0] = s[0] == '0' ? '1' : '0';
            s[1] = s[1] == '0' ? '1' : '0';
        } else if (index == n) {
            s[n] = s[n] == '0' ? '1' : '0';
            s[n - 1] = s[n - 1] == '0' ? '1' : '0';
        } else if (index > 0 && index < n) {
            s[index - 1] = s[index - 1] == '0' ? '1' : '0';
            s[index] = s[index] == '0' ? '1' : '0';
            s[index + 1] = s[index + 1] == '0' ? '1' : '0';
        }
        return s;
    }
};

int main() {
    Solution solu = Solution();
    string str = "011111";
    int res = solu.reverse(str);
    if (res != -1) {
        cout << res << endl;
    } else {
        cout << "No";
    }
    return 0;
}
```

### 2.射鹿

有n头鹿，m只箭，每头鹿都有一定的血量，每只箭也有相应的伤害值，使用每只箭都有相应的花费，当箭的伤害值大于等于鹿的血量时，可以将其射死，问如果能将所有鹿射死，求需要的最少花费是多少，如果不能全部射死，就输出NO。
样例：
1 // 测试用例的组数
3 3 // n,m
1 2 3 // 鹿的血量
2 3 4 // 箭的伤害值
1 2 3 // 箭的花费
6 // 输出最小花费

#### 参考代码

``` c++
#include <algorithm>
#include <iostream>
#include <queue>
#include <vector>

using namespace std;

/**
 * 思路：将鹿按血量排序，定义一个箭的结构体，包含伤害值和花费两个属性，将箭按照伤害值排序，
 * 然后对每只鹿，用能将其射死且花费最小的箭射它，这儿用到按花费排序的优先队列。
 */

struct Arrow {
    int damage;
    int cost;
    Arrow(int x, int y) : damage(x), cost(y) {}
};

struct cmp {
    bool operator()(Arrow* a1, Arrow* a2) { return a1->cost > a2->cost; }
};

bool static compare(Arrow* a1, Arrow* a2) { return a1->damage < a2->damage; }

int main() {
    int T;
    cin >> T;
    for (int i = 0; i < T; i++) {
        int N, M;
        cin >> N >> M;
        vector<int> nums(N, 0);
        vector<Arrow*> arrows;
        for (int i = 0; i < N; i++) {
            cin >> nums[i];
        }
        vector<int> damage(M, 0);
        for (int i = 0; i < M; i++) {
            cin >> damage[i];
        }
        vector<int> cost(M, 0);
        for (int i = 0; i < M; i++) {
            cin >> cost[i];
        }
        for (int i = 0; i < M; i++) {
            Arrow* arrow = new Arrow(damage[i], cost[i]);
            arrows.push_back(arrow);
        }

        if (N > M) {
            cout << "NO";
        } else {
            // 定义优先队列 用于按花费大小存储伤害值高于血量的箭
            priority_queue<Arrow*, vector<Arrow*>, cmp> q;
            int res = 0;                                  // 记录结果
            bool can = true;                              // 能否全部射死
            sort(nums.begin(), nums.end());               // 按血量排序
            sort(arrows.begin(), arrows.end(), compare);  // 按伤害值排序

            int j = M - 1;
            for (int i = N - 1; i >= 0; i--) {
                // 将能射死当前鹿的箭入优先队列
                while (j >= 0 && arrows[j]->damage >= nums[i]) {
                    q.push(arrows[j]);
                    j--;
                }
                // 如果没有能射死当前鹿的箭，则不能全部射死
                if (q.size() == 0) {
                    cout << "NO";
                    can = false;
                    break;
                    //否则拿出花费最小的箭射死当前鹿
                } else {
                    Arrow* arrow = q.top();
                    q.pop();
                    res += arrow->cost;
                }
            }
            if (can) {
                cout << "Total cost: " << res;
            }
        }
    }
}
```

## 华为

## 快手

## 美团

## 拼多多

## 头条

## 网易互娱
