#include <bits/stdc++.h>

using namespace std;

/**
 * 头条的2017校招开始了！为了这次校招，我们组织了一个规模宏大的出题团队，每个出题人都出了一些有趣的题目，
 * 而我们现在想把这些题目组合成若干场考试出来，在选题之前，我们对题目进行了盲审，并定出了每道题的难度系统。
 * 一场考试包含3道开放性题目，假设他们的难度从小到大分别为a,b,c，我们希望这3道题能满足下列条件：
 * a<=b<=c
 * b-a<=10
 * c-b<=10
 * 所有出题人一共出了n道开放性题目。现在我们想把这n道题分布到若干场考试中（1场或多场，每道题都必须使用且只能用一次），
 * 然而由于上述条件的限制，可能有一些考试没法凑够3道题，因此出题人就需要多出一些适当难度的题目来让每场考试都达到要求，
 * 然而我们出题已经出得很累了，你能计算出我们最少还需要再出几道题吗
 *
 * 思路：先对难度进行排序，然后依次判断，连续的题目是否可以构成一套试卷。具体看代码
 */

const int N = 100010;

int n;
int d[N];

int main() {
    cin >> n;
    for (int i = 0; i < n; i++) cin >> d[i];
    sort(d, d + n);        // 先排序
    int res = 0, cnt = 1;  // cnt 用于记录当前这套试卷的题目
    for (int i = 1; i < n; i++) {  // 从1开始遍历已有题目
        if (cnt < 3) {             // 如果当前题目小于3
            // 相邻两题的难度差小于10，则放入当前试卷
            if (d[i] - d[i - 1] <= 10) cnt++;
            // 如果相邻两题的难度小于20，则说明在中间插入一个新题，可以构成一套试卷，
            else if (cnt == 1 && d[i] - d[i - 1] <= 20) {
                res++;
                cnt = 3;
                // 否则前面一道题和当前题目不能放在同一套试卷，新增3-cnt道题构成一套试卷，当前则作为新试卷的第一道题
            } else {
                res += 3 - cnt;
                cnt = 1;
            }
            // cnt为3时，说明已经构建了一套试卷，则令cnt=1，构建新的试卷
        } else {
            cnt = 1;
        }
    }
    res += 3 - cnt;  // 注意还需要考虑最后一套试卷的情况
    cout << res << endl;
    return 0;
}