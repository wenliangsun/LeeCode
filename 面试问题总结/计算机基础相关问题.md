# 操作系统常见面试题

## 什么是进程和线程，有什么区别？

**进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元**。

**进程**：进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位，实现了操作系统的并发。进程一般由**程序、数据集、进程控制块**三部分组成。（如：用户运行自己的程序，系统就创建一个进程，并为它分配资源，包括各种表格、内存空间、磁盘空间、I/O设备等，然后该进程被放入到进程的就绪队列，进程调度程序选中它，为它分配CPU及其他相关资源，该进程就被运行起来）

**线程**：线程是进程的实体，是CPU调度和分派的基本单位。它是比进程更小的能独立运行的基本单位。线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（如程序计数器，一组寄存器和栈），但是它可**与同属一个进程的其他的线程共享进程所拥有的全部资源**。一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。引入线程的优点：(1)易于调度；（2）提高并发性。通过线程可以方便有效地实现并发；(3)开销小，创建线程比创建进程要快，所需要的开销也更小。

在没有实现线程的操作系统中，进程既是资源分配的基本单位，又是调度的基本单位，它是系统中并发执行的单元。而在实现了线程的操作系统中，进程是资源分配的基本单位，但是线程是调度的基本单位，是系统中并发执行的单元。

**区别**：

1. 一个程序至少有一个进程，一个进程至少有一个线程(主线程)，线程依赖于进程而存在。
2. 进程在执行过程中拥有独立的内存单元，而多个线程共享进程的内存空间。
3. 属于一个进程的所有线程共享改进程的所有资源，不同的进程互相独立。
4. 线程又被称为轻量级的进程，进程有进程控制块，线程有线程控制块。但线程控制块比进程控制块小得多，线程间切换代价小，进程间切换代价大。
5. 进程是程序的一次执行，线程可以理解为程序中一段程序片段的执行。

## 进程的状态及其转换

1. 就绪状态：当进程已经分配到除CPU以外的所有必要的资源，只要获得处理机便可立即执行；
2. 运行状态：当进程已获得处理机，其程序正在处理机上执行；
3. 阻塞状态：正在执行的进程，由于某个事件发生而无法执行时，便放弃处理机而处于阻塞状态；引起进程阻塞状态的事件可以有多种，例如，等待I/O完成、申请缓冲区不能满足、等待信件（信号）。

注意区别就绪状态和等待状态：就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源（除了处理机）或等待某一事件。

**就绪状态 -> 运行状态**：处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。
**运行状态 -> 就绪状态**：处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就 、 绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。
**运行状态 -> 阻塞状态**：当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I/O操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。
**阻塞状态 -> 就绪状态**：当进程等待的事件到来时，如I/O操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。

## 进程间的通信方式有哪些？

1. **管道(pipe)及命名管道**：管道可用于具有亲缘关系的父子进程间的通信，*有名管道*除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；
2. **信号(signal)**：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
3. **消息队列**：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；
4. **共享内存**：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；
5. **信号量**：主要作为进程之间及同一种进程的不同线程之间得同步和互斥手段；
6. **套接字**：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。

## 线程同步的方式有哪些？

1. **临界区**：通过对多线程的串行化来访问公共资源或一段代码，速度快，适合控制数据访问。
2. **互斥量**：为协调对一个共享资源的单独访问而设计，采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。互斥不仅能实现同一应用程序的公共资源安全共享，还能实现不同应用程序的公共资源安全共享。
3. **信号量**：为控制一个具有有限数量的用户资源而设计。它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。
4. **事件(信号)**：用来通知线程有一些事件已发生，从而启动后继任务的开始保持多线程同步，也可方便的实现多线程优先级的比较操作。

## 什么是缓冲区溢出？有什么危害？其原因是什么？

**缓冲区溢出**：是指当计算机向缓冲区内填充数据时超过了缓冲区本身的容量，溢出的数据覆盖在合法数据上的情况。

**危害**：缓冲区溢出中，最为危险的是堆栈溢出，因为入侵者可以利用堆栈溢出，在函数返回时改变返回程序的地址，让其跳转到任意地址，带来的危害一种是程序崩溃导致拒绝服务，另外一种就是跳转并且执行一段恶意代码，比如得到shell，然后为所欲为。通过往程序的缓冲区写超出其长度的内容，造成缓冲区的溢出，从而破坏程序的堆栈，使程序转而执行其它指令，以达到攻击的目的。

**主原因**：造成缓冲区溢出的主原因是程序中没有仔细检查用户输入的参数。

## 什么是死锁？死锁产生的条件？

**死锁**：所谓死锁是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去，此时称系统处于死锁状态或系统产生了死锁。通俗的讲，就是两个或多个进程无限期的阻塞、相互等待的一种状态。

**死锁产生的条件**：

1. **互斥条件**：一个资源每次只能被一个进程使用；若其他进程申请使用该资源，必须等到该资源被释放为止；
2. **请求与保持条件**：一个进程因请求资源而阻塞时，对已获取的资源保持不放；
3. **不可剥夺条件**：进程已获得资源，在未使用完之前，不能强行剥夺；
4. **循环等待条件**：若干进程之间形成一种头尾相接的环形等待资源关系。

死锁预防的基本思想是：只要确保死锁发生的四个必要条件中至少有一个不成立，就能预防死锁的发生。

## 内存管理有哪几种方式?

内存管理有块式管理、页式管理、段式和短页式管理。

1. **块式管理**：把主存分为一大块、一大块的，当所需的程序片断不在主存时就分配一块主存空间，把程序片断load入主存，就算所需的程序片度只有几个字节也只能把这一块分配给它。这样会造成很大的浪费，平均浪费了50％的内存空间，但是易于管理。
2. **页式管理**：把主存分为一页一页的，每一页的空间要比一块一块的空间小很多，显然这种方法的空间利用率要比块式管理高很多。
3. **段式管理**：把主存分为一段一段的，每一段的空间又要比一页一页的空间小很多，这种方法在空间利用率上又比页式管理高很多，但是也有另外一个缺点。一个程序片断可能会被分为几十段，这样很多时间就会被浪费在计算每一段的物理地址上。
4. **段页式管理**：结合了段式管理和页式管理的优点。将程序分成若干段，每个段分成若干页。段页式管理每取一数据，要访问3次内存。

## 分页和分段有什么区别？

段式存储管理是一种符合用户视角的内存分配管理方案。在段式存储管理中，将程序的地址空间划分为若干段（segment），如代码段，数据段，堆栈段；这样每个进程有一个二维地址空间，相互独立，互不干扰。段式管理的优点是：没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。

页式存储管理方案是一种用户视角内存与物理内存相分离的内存分配管理方案。在页式存储管理中，将程序的逻辑地址划分为固定大小的页（page），而物理内存划分为同样大小的帧，程序加载时，可以将任意一页放入内存中任意一个帧，这些帧不必连续，从而实现了离散分配。页式存储管理的优点是：没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）。

**两者的不同**：

1. **目的不同**：分页是由于系统管理的需要而不是用户的需要，它是信息的物理单位；分段的目的是为了能更好地满足用户的需要，它是信息的逻辑单位，它含有一组其意义相对完整的信息；
2. **大小不同**：页的大小固定且由系统决定，而段的长度却不固定，由其所完成的功能决定；
3. **地址空间不同**： 段向用户提供二维地址空间；页向用户提供的是一维地址空间；
4. **信息共享**：段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制；
5. **内存碎片**：页式存储管理的优点是没有外碎片（因为页的大小固定），但会产生内碎片（一个页可能填充不满）；而段式管理的优点是没有内碎片（因为段大小可变，改变段大小来消除内碎片）。但段换入换出时，会产生外碎片（比如4k的段换5k的段，会产生1k的外碎片）。

## 页面置换算法

1. **最佳置换算法OPT**：只具有理论意义的算法，用来评价其他页面置换算法。置换策略是将当前页面中在未来最长时间内不会被访问的页置换出去。
2. **先进先出置换算法FIFO**：简单粗暴的一种置换算法，没有考虑页面访问频率信息。每次淘汰最早调入的页面。
3. **最近最久未使用算法LRU**：算法赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间t，每次置换的时候把t值最大的页面置换出去(实现方面可以采用寄存器或者栈的方式实现)。
4. **时钟算法clock(也被称为是最近未使用算法NRU)**：页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为为0，那么置换，否则将其置为0，循环直到遇到一个访问为位0的页面。
5. **改进型Clock算法**：在Clock算法的基础上添加一个修改位，替换时根究访问位和修改位综合判断。优先替换访问位和修改位都是0的页面，其次是访问位为0修改位为1的页面。
6. **LFU最少使用算法LFU**：设置寄存器记录页面被访问次数，每次置换的时候置换当前访问次数最少的。

## 操作系统中进程调度策略有哪几种？

1. **先来先服务调度算法FCFS**：队列实现，非抢占，先请求CPU的进程先分配到CPU，可以作为作业调度算法也可以作为进程调度算法；按作业或者进程到达的先后顺序依次调度，对于长作业比较有利；
2. **最短作业优先调度算法SJF**：作业调度算法，算法从就绪队列中选择估计时间最短的作业进行处理，直到得出结果或者无法继续执行，平均等待时间最短，但难以知道下一个CPU区间长度；缺点：不利于长作业；未考虑作业的重要性；运行时间是预估的，并不靠谱 ；
3. **优先级调度算法(可以是抢占的，也可以是非抢占的)**：优先级越高越先分配到CPU，相同优先级先到先服务，存在的主要问题是：低优先级进程无穷等待CPU，会导致无穷阻塞或饥饿；
4. **时间片轮转调度算法(可抢占的)**：按到达的先后对进程放入队列中，然后给队首进程分配CPU时间片，时间片用完之后计时器发出中断，暂停当前进程并将其放到队列尾部，循环 ;队列中没有进程被分配超过一个时间片的CPU时间，除非它是唯一可运行的进程。如果进程的CPU区间超过了一个时间片，那么该进程就被抢占并放回就绪队列。
5. **高相应比算法HRN**：响应比=(等待时间+要求服务时间)/要求服务时间；
6. **多级队列调度算法**：将就绪队列分成多个独立的队列，每个队列都有自己的调度算法，队列之间采用固定优先级抢占调度。其中，一个进程根据自身属性被永久地分配到一个队列中。
7. **多级反馈队列调度算法**：目前公认较好的调度算法；设置多个就绪队列并为每个队列设置不同的优先级，第一个队列优先级最高，其余依次递减。优先级越高的队列分配的时间片越短，进程到达之后按FCFS放入第一个队列，如果调度执行后没有完成，那么放到第二个队列尾部等待调度，如果第二次调度仍然没有完成，放入第三队列尾部…。只有当前一个队列为空的时候才会去调度下一个队列的进程。与多级队列调度算法相比，其允许进程在队列之间移动：若进程使用过多CPU时间，那么它会被转移到更低的优先级队列；在较低优先级队列等待时间过长的进程会被转移到更高优先级队列，以防止饥饿发生。

## 说一说进程同步有哪几种机制

原子操作、信号量机制、自旋锁管程、会合、分布式系统

### 父进程与子进程

Linux 操作系统提供了一个 **fork() 函数用来创建子进程**，这个函数很特殊，调用一次，返回两次，因为操作系统是将当前的进程（父进程）复制了一份（子进程），然后分别在父进程和子进程内返回。子进程永远返回0，而父进程返回子进程的 PID。我们**可以通过判断返回值是不是 0 来判断当前是在父进程还是子进程中执行**。

### 子进程如何回收

Python中采用os.wait()方法用来回收子进程占用的资源。如果有子进程没有被回收的，但是父进程已经死掉了，这个子进程就是僵尸进程。

## 参考资料

[面试中操作系统常见问题总结](https://blog.csdn.net/Yasin0/article/details/81879569)
[操作系统原理常见面试题总结](https://blog.csdn.net/yubujian_l/article/details/87821500#1.%20%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F)
[常见面试题整理](https://zhuanlan.zhihu.com/p/23755202)


# 计算机网络常见面试题

[计算机网络常见面试题总结](https://blog.csdn.net/yubujian_l/article/details/87893871)
[计算机网络常见笔试面试题](https://blog.csdn.net/xiongluo0628/article/details/81394982?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.nonecase)

## OSI、TCP/IP、五层协议的体系结构？

| OSI层  | 对应的TCP/IP层 | OSI各层功能                                              | 网络协议                    | 设备           |
| ------ | -------------- | -------------------------------------------------------- | --------------------------- | -------------- |
| 应用层 | 应用层         | 应用程序（电子邮件，文件服务），用户接口                 | HTTP、FTP、TFTP、NFS        | 网关           |
| 表示层 | 应用层         | 数据的表示，压缩和加密（数据格式化，代码转换，数据加密） | TELNET、SNMP                | 网关           |
| 会话层 | 应用层         | 建立、管理和终止会话                                     | SMTP、DNS                   | 网关           |
| 传输层 | 传输层         | 提供端到端可靠报文段传递和错误恢复                       | TCP、UDP                    | 网关           |
| 网络层 | 网际互联层     | 提供数据包从源到宿的传递和网际交互                       | IP、ICMP、ARP、RARP、UUCP   | 路由器         |
| 链路层 | 网络接口层     | 将比特组装成帧和点到点传递                               | FDDI、SLIP、PPP、PDN        | 交换机         |
| 物理层 | 网络接口层     | 传输比特流，以二进制数据形式在物理媒介上传输数据         | ISO2110、IEEE802、IEEE802.2 | 集线器、中继器 |

### OSI参考模型(七层)：

1. 应用层：为操作系统或网络应用程序提供访问网络服务的接口。所有能产生网络流量的程序。
2. 表示层：对上层数据或信息进行变换以保证一个主机应用层信息可以被另一个主机应用程序理解。表示层的数据转换包括数据的加密、压缩、格式转换等。
3. 会话层：管理主机之间的会话进程，即负责建立、管理、终止进程间的会话。会话层还利用在数据中插入校验点来实现数据的同步。
4. 传输层：负责将上层数据分段并提供端到端的、可靠的或不可靠的传输。此外，传输层还要处理端到端的差错控制和流量控制问题。
5. 网络层：负责对子网间的数据包进行路由选择。此外，网络层还可以实现拥塞控制、网际互连等功能。
6. 数据链路层：数据链路层在不可靠的物理介质上提供可靠的传输。改层的作用包括：物理地址寻址、数据的成帧、流量控制、数据的检错、重发等。帧的开始与结束，透明传输，差错校验
7. 物理层：激活、维持、关闭通信短点之间的机械特性、电气特性、功能特性以及工程特性。该层为上层协议提供了一个传输数据的物理媒体。接口标准，电气标准，如何在物理链路层上传输更快的速度。

### TCP/IP(四层)

应用层、运输层、网际互联层、网络接口层

### 五层协议(五层)：

应用层、运输层、网络层、数据链路层、物理层

## 简述TCP/UDP的区别

TCP和UDP是OSI模型中的运输层中的协议。TCP提供可靠的通信传输，而UDP则常被用于让广播和细节控制交给应用的通信传输。

**区别**：

1. TCP面向连接，UDP面向非连接（即发送数据前不需要建立链接）。TCP是面向连接的，使用 TCP连接需要经过三次握手，断开连接需要经过四次挥手。相比于TCP，UDP则是面向无连接的，它像一个随时可以进行通信的协议，只要接收方创建了Socket，设置了监听端口，就能接收到到达的UDP包，并且能随时建立Socket进行发包。
2. TCP提供可靠的服务（数据传输），UDP无法保证。TCP保证可靠的数据传输，它根据速率控制，重传控制，还有数据校验保证提供可靠的数据传输服务。而UDP只是保证尽力而为地传输数据，并不保证数据的可靠性。
3. TCP面向字节流，UDP面向报文。
4. TCP数据传输慢，UDP数据传输快。TCP的报文段头部占20个字节，比UDP的报文段头部多12个字节。消耗的资源更多。由于建立连接有握手的机制，TCP的使用效率会比UDP要低一些。

**TCP对应的协议**：
（1）FTP：定义了文件传输协议，使用21端口。
（2）Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。
（3）SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。
（4）POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。
（5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。默认端口：80
**UDP对应的协议**：
（1）DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
（2）SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
（3）TFTP(Trival File Tran敏感词er Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。

## 在浏览器中输入www.baidu.com后执行的全部过程

1. 浏览器获取输入的域名 www.baidu.com;
2. 浏览器向DNS请求解析 www.baidu.com的IP地址;
3. 域名系统DNS解析出百度服务器的IP地址;
4. 浏览器与该服务器建立TCP连接(默认端口号80);
5. 浏览器发出HTTP请求，请求百度首页;
6. 服务器通过HTTP响应把首页文件发送给浏览器;
7. TCP连接释放;
8. 浏览器将首页文件进行解析，并将Web页显示给用户。

**涉及到的协议**：

1. 应用层：HTTP(WWW访问协议)，DNS(域名解析服务)
2. 传输层：TCP(为HTTP提供可靠的数据传输)，UDP(DNS使用UDP传输)
3. 网络层：IP(IP数据数据包传输和路由选择)，ICMP(提供网络传输过程中的差错检测)，ARP(将本机的默认网关IP地址映射成物理MAC地址)

## TCP三次握手和四次挥手过程？

**三次握手**：即建立TCP连接，就是指建立一个TCP连接时，需要客户端和服务端总共发送3个包以确认连接的建立。

1. 第一次握手：客户端将标志位SYN设置为1，随机产生一个值seq=J，并将该数据包发送给服务器，客户端进入SYN_SENT状态，等待服务器确认。
2. 第二次握手：服务器收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器将标志位SYN和ACK都设置为1，ack=J+1,随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器进入SYN_RCVD状态。
3. 第三次握手：客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK设置为1，ack=K+1，并将该数据包发送给服务器，服务器检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器进入ESTABLISHED状态，就可以传输数据了。

**四次挥手**：四次挥手即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。由于TCP连接时全双工的，因此，每个方向都必须单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是这个TCP连接上仍能够发送数据，直到这一方也发送了FIN，首次进行关闭的一方执行主动关闭，而另一方则执行被动关闭。

1. 第一次挥手：客户端发送一个FIN，用来关闭客户端到服务器的数据传输，客户端进入FIN_WAIT_1状态；
2. 第二次挥手：服务器收到FIN后，发送一个ACK给客户端，确认序号为收到信号+1，服务器进入CLOSE_WAIT状态；
3. 第三次挥手：服务器发送一个FIN，用来关闭服务器到客户端的数据传输，服务器进入LAST_ACK状态；
4. 第四次挥手：客户端收到FIN后，客户端进入TIME_WAIT状态，接着发送一个ACK给服务器，确认序号为收到信号+1，服务器进入CLOSED状态，完成四次挥手。

## TCP为什么需要三次握手？两次握手不行吗？

采用三次握手是为了防止失效的连接请求报文段突然又传送到服务器，因而产生错误。失效的连接请求报文段是指：客户端发出的连接请求没有收到服务器的确认，于是经过一段时间后，客户端又重新向服务器发送连接请求，且连接建立成功。考虑这样一种特殊情况，客户端第一次发送的连接请求并没有丢失，而是因为网络节点导致延迟达到服务器，服务器以为是客户端又发起的新连接，于是服务器同意连接，并向客户端发回确认，但是此时客户端根本不会理会，服务器就一直在等待客户端发送数据，导致服务器的资源浪费。

采用两次握手不行，原因就是上面说的实效的连接请求的特殊情况。

## DNS域名系统，简单描述其工作原理

1. 在浏览器中输入www.qq.com域名，操作系统会先检查自己本地的hosts文件是否有这个网址映射关系，如果有，就先调用这个IP地址映射，完成域名解析。
2. 如果hosts里没有这个域名的映射，则查找本地DNS解析器缓存，是否有这个网址映射关系，如果有，直接返回，完成域名解析。
3. 如果hosts与本地DNS解析器缓存都没有相应的网址映射关系，首先会找TCP/ip参数中设置的首选DNS服务器，在此我们叫它本地DNS服务器，此服务器收到查询时，如果要查询的域名，包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析，此解析具有权威性。
4. 如果要查询的域名，不由本地DNS服务器区域解析，但该服务器已缓存了此网址映射关系，则调用这个IP地址映射，完成域名解析，此解析不具有权威性。
5. 如果本地DNS服务器本地区域文件与缓存解析都失效，则根据本地DNS服务器的设置（是否设置转发器）进行查询，如果未用转发模式，本地DNS就把请求发至13台根DNS，根DNS服务器收到请求后会判断这个域名(.com)是谁来授权管理，并会返回一个负责该顶级域名服务器的一个IP。本地DNS服务器收到IP信息后，将会联系负责.com域的这台服务器。这台负责.com域的服务器收到请求后，如果自己无法解析，它就会找一个管理.com域的下一级DNS服务器地址(qq.com)给本地DNS服务器。当本地DNS服务器收到这个地址后，就会找qq.com域服务器，重复上面的动作，进行查询，直至找到www.qq.com主机。
6. 如果用的是转发模式，此DNS服务器就会把请求转发至上一级DNS服务器，由上一级服务器进行解析，上一级服务器如果不能解析，或找根DNS或把转请求转至上上级，以此循环。不管是本地DNS服务器用是是转发，还是根提示，最后都是把结果返回给本地DNS服务器，由此DNS服务器再返回给客户机。

## ARP是地址解析协议，简单语言解释一下工作原理

1. 首先，每个主机都会在自己的ARP缓冲区中建立一个ARP列表，以表示IP地址和MAC地址之间的对应关系。
2. 当源主机要发送数据时，首先检查ARP列表中是否有对应IP地址的目的主机的MAC地址，如果有，则直接发送数据，如果没有，就向本网段的所有主机发送ARP数据包，该数据包包括的内容有：源主机IP地址，源主机MAC地址，目的主机的IP地址。
3. 当本网络的所有主机收到该ARP数据包时，首先检查数据包中的IP地址是否是自己的IP地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的IP和MAC地址写入到ARP列表中，如果已经存在，则覆盖，然后将自己的MAC地址写入ARP响应包中，告诉源主机自己是它想要找的MAC地址。
4. 源主机收到ARP响应包后。将目的主机的IP和MAC地址写入ARP列表，并利用此信息发送数据。如果源主机一直没有收到ARP响应数据包，表示ARP查询失败。
5. 广播发送ARP请求，单播发送ARP响应


# 数据库常见面试题

待填。。。

# C++相关问题

[C++常见面试题](https://juejin.im/entry/5d887de8f265da03dc07ade9)
[112道c++常见面试题整理](https://zhuanlan.zhihu.com/p/136014054)

## C/C++程序内存中各种变量的存储区域(内存管理)

1. 栈区(地址从高到低扩展)：由编译器自动分配释放，存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈。
2. 堆区(地址从低到高扩展)：一般由程序员分配释放，存放由malloc和new申请的内存块，需要对堆中的数据及时销毁，防止内存泄露，使用free和delete销毁new和malloc申请的堆内存，分配方式倒是类似于链表。若程序员不释放，例如malloc、free，程序结束时可能由OS回收。
3. 全局区(静态区static)：程序结束后由系统释放，存放全局变量和静态变量。初始化的全局变量和静态变量在一块区域，未初始化的全局变量和未初始化的静态变量在相邻的另一块区域，全局区内存在程序编译时已经分配好，并存在于程序的整个运行时间。
4. 文字常量区：程序结束后由系统释放，存放常量字符串。
5. 程序代码区：存放函数体的二进制代码。

## 栈区和堆区的差异/优缺点？

1. 栈区：由系统自动分配，速度快，但是程序员无法控制。(只要栈的剩余空间大于所申请的空间，系统将为程序提供内存，否则将报异常提示栈溢出。)
2. 堆区：是由malloc/new分配的内存，一般速度比较慢，而且容易产生内存碎片。内存碎片有三种形式：
   (1) 额外开销：内存分配程序需要存储一些描述其分配状态的数据。这些存储的信息包括任何一个空闲内存块的位置、大小和所有权，以及其它内部状态详情。
   (2) 外部碎片的产生是当已分配内存块之间出现未被使用的差额时，就会产生外部碎片。例如A申请了3个连续的内存块，中间的一个使用完之后被释放，但是如果再申请内存时，空间超过了中间部分的内存，那么这部分内存就不会被使用。
   (3) 由所需大小四舍五入而产生的多余空间就叫内部碎片(结构体内存对齐)。

```c++
int a = 0;  //全局初始化区
char *p1; //全局未初始化区
int main() {
    int b;               // 栈区
    char s[] = "abc";    // 栈区
    char *p2;            // 栈区
    char *p3 = "123456"; // 123456\0在常量区，p3在栈上
    static int c=0;      // 全局初始化区
    p1 = (char*)malloc(10);
    p2 = (char*)malloc(20);  // 程序员分配，在堆区
    strcpy(p1,"123456");     // 123456\0放在常量区，编译器可能会将它与p3所向"123456"优化成一个地方
}
```

## 指针和引用的区别

本质：**引用是一个内存对象的别名，指针指向一个内存对象，保存了这个对象的内存地址**，具体的：

1. 引用不能为空，即不存在对空对象的引用，指针则可以为空，指向空对象；
2. 引用必须初始化，指定对哪个对象的引用，指针不需要；
3. 引用初始化后不能改变，指针可以改变所指对象的值；
4. 引用访问对象是直接访问，指针访问对象是间接访问；
5. 引用的大小(sizeof)是所引用对象的大小，指针的大小是指针本身大小，通常是4字节；
6. 引用没有const，指针有const，const的指针不可变；
7. 引用和指针的++自增运算符意义不同；
8. 引用不需要分配内存空间，指针需要。

## const和define有什么区别？

本质：define只是字符串替换，const参与编译运行。具体的：

1. define 不会做类型检查，const拥有类型，会执行相应的类型检查。
2. define仅仅是宏替换，不占用内存，而const会占用内存。
3. const内存效率更高，编译器通常将const变量保存在符号表中，而不会分配存储空间，这使得它成为一个编译期间的常量，没有存储和读取操作。

## 宏(define)和内联函数(inline)有什么区别？

本质：宏只是字符串替换，内联函数由编译器控制，具体的：

1. 编译内联函数可以嵌入到目标代码，宏只是简单的文本替换，宏通常会产生二义性;
2. 宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的;
3. inline函数是否展示由编译器决定，有时候当函数太大时，编译器可能选择不展开相应的函数(当作非内联函数处理)。
4. inline会做类型、语法检查，而define不具备这样的功能；
5. define不是函数，inline函数是函数。

**内联函数的优点与缺点**：

优点：
1. inline定义的内联函数，函数代码被放入符号表中，在使用时进行替换（像宏一样展开），效率很高；
2. 类的内联函数也是函数。编绎器在调用一个内联函数，首先会检查参数问题，保证调用正确，像对待真正函数一样，消除了隐患及局限性；
3. inline可以作为类的成员函数，可以使用所在类的保护成员及私有成员。

缺点：
1. 内联函数以复制为代价，活动产生开销；
2. 如果函数的代码较长，使用内联将消耗过多内存，这种情况编译器可能会自动把它作为非内联函数处理；
3. 如果函数体内有循环，那么执行函数代码时间比调用开销大。

## malloc和new有什么区别？free和delete有什么区别？

1. malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符，他们都可以用于申请动态内存和释放内存；
2. malloc分配内存前需要手工计算分配多大的空间，new能自动计算需要分配的内存空间；
3. malloc是最底层函数，不会调用构造函数，函数返回值是void*，new运算符需要调用构造函数，函数返回相应对象类型的指针
4. new是类型安全的，如`int *p = new float[2]`编译器会报错，而malloc不是，`int *p = malloc(2*sizeof(float))`编译时编译器无法指出错误；
5. new一般由两步构成，分别是new操作和构造，new对应malloc，但是new操作可以重载，可以自定义内存分配策略，但是malloc不行。

## C++中static关键字的作用有哪些？

1. 修饰局部变量：static修饰局部变量时，使得被修饰的变量成为静态变量，存储在静态区。存储在静态区的数据生命周期与程序相同，在main函数之前初始化，在程序退出时销毁。（无论是局部静态还是全局静态）
2. 修饰全局变量：全局变量本来就存储在静态区，因此static并不能改变其存储位置。但是，static限制了其链接属性。被static修饰的全局变量只能被该包含该定义的文件访问（即改变了作用域）。
3. 修饰函数：static修饰函数使得函数只能在包含该函数定义的文件中被调用。 对于静态函数，声明和定义需要放在同一个文件夹中。
4. 修饰成员变量：用static修饰类的数据成员使其成为类的全局变量，会被类的所有对象共享，包括派生类的对象，所有的对象都只维持同一个实例。 因此， static成员必须在类外进行初始化 (初始化格式：int base::var=10;)，而不能在构造函数内进行初始化，不过也可以用const修饰static数据成员在类内初始化。
5. 修饰成员函数：用static修饰成员函数，使这个类只存在这一份函数，所有对象共享该函数，不含this指针，因而只能访问类的static成员变量。静态成员是可以独立访问的，也就是说，无须创建任何对象实例就可以访问。
6. 隐藏：当同时编译多个文件时，所有未加static前缀的全局变量和函数都具有全局可见性，其它的源文件也能访问。利用这一特性可以在不同的文件中定义同名函数和同名变量，而不必担心命名冲突。static可以用作函数和变量的前缀，对于函数来讲，static的作用仅限于隐藏。

## C++中const关键字作用有哪些？

1. 定义变量为只读变量，不可修改
2. 修饰函数的参数和返回值（后者应用比较少，一般为值传递）
3. const成员函数（只需要在成员函数参数列表后加上关键字const，如char  get() const;）可以访问const成员变量和非const成员变量，但不能修改任何变量。 在声明一个成员函数时，若该成员函数并不对数据成员进行修改操作，应尽可能将该成员函数声明为const成员函数。
4. const对象只能访问const成员函数,而非const对象可以访问任意的成员函数,包括const成员函数.即对于class A，有const A a； 那么a只能访问A的const成员函数。而对于：A b；b可以访问任何成员函数。
5. 使用const关键字修饰的变量，一定要对变量进行初始化

## C++中成员函数能够同时用static和const进行修饰吗？

**不可以**， C++编译器在实现const的成员函数的时候为了确保该函数不能修改类的实例的状态，会在函数中添加一个隐式的参数const this*。但当一个成员为static的时候，该函数是没有this指针的。也就是说此时const的用法和static是冲突的。 我们也可以这样理解：两者的语意是矛盾的。static的作用是表示该函数只作用在类型的静态变量上，与类的实例没有关系；而const的作用是确保函数不能修改类的实例的状态，与类型的静态变量没有关系。因此不能同时用它们。

## 下面三个变量分别代表什么含义？

```c++
const int *ptr;
int const *ptr;
int * const ptr;
```
前两个代表指向const变量的指针，即指针所指向的对象是const的，不能使用指针修改，最后一个代表const指针，即指针本身是const的，不能指向其它地址。前两个表示：指针指向的内容不能改变，指针本身可以改变。第三个表示：指针本身不能改变，指针指向的内容可以改变。

## C++中全局变量和静态变量的区别

1. 全局变量的作用域是整个项目，它只需要在一个源文件中定义就可以作用于所有的源文件，其它不包括全局变量定义的文件需要使用extern关键字再次声明这个全局变量即可。
2. 全局变量、静态全局变量、静态局部变量都是在静态存储区中分配空间，而局部变量是在栈空间上分配空间。
3. 全局变量、静态变量的生命周期和程序的声明周期是一样的，在程序结束之后操作系统会回收空间。
4. 全局变量和静态全局变量、静态局部变量默认值都是0，也就是在没有初始化变量值的时候默认为0。
5. 静态变量包含静态局部变量和静态全局变量。 静态局部变量具有局部作用域只对定义自己的函数可见，只被初始化一次，自从初始化一次之后直到程序运行期间一直都在。静态全局变量具有全局作用域作用于定义它的程序文件但是不能作用于项目里的其它文件，这一点和全局变量不同。静态全局变量可以被多次初始化。把局部变量改变为静态变量之后是改变了它的存储方式和生命期。把全局变量改变为静态变量之后是改变了它的作用域，限制了使用范围(当前程序文件)。

```c++
// 静态局部变量
int fun() {
    static int num = 0; // 声明一个静态局部变量，只会初始化一次
    ++num;
    return num;
}

int main() {
    for (int i = 0; i < 10; i++) 
        cout << fun() <<' ';
    return 0;
}

/*
输出结果是
1 2 3 4 5 6 7 8 9 10
*/
/*解释如下
1. 静态局部变量只会被初始化一次，因此第一次调用Fun函数的时候num被初始化为0
2. 然后每次调用的时候++num，第一次调用++num为1；第二次++num为2......
3. 静态局部变量的生命期是整个程序因此值可以保存下来
*/

// 测试静态全局变量
static int val;

void fun() {
    val = 0;
    ++val;
}

int main() {
    for (int i = 0; i < 10; i ++) {
        fun();
        cout << val << " ";
    }
    return 0;
}
/*
输出1 1 1 1 1 1 1 1 1 1
解释
1. 静态全局变量可以被初始化多次，因为每次调用G函数都会对静态全局变量初始化为0
2. 每次value的值都初始化为0，++value为1，因此输出的值为1
*/

//测试静态局部变量
int Get(int x){
    static int count = x;
	return count+x;
}
printf("%d %d\n", Get(4), Get(5));
/*
输出9 10
解释：
1.printf是一个函数，根据函数参数入栈的顺序是从右到左，则先调用Get(5)再调用Get(4)
2.调用Get(5)的时候，count第一次被初始化为5，则返回10；第二次调用Get(4)的时候count不再被初始化值为5返回9
*/
```

## C/C++中结构体所占字节数

在使用sizeof运算符计算结构体所占的空间时，并不是简单的将结构体中的所有元素各自占的空间相加，需要考虑字节对齐的问题。从理论上讲，对于任何变量的访问都可以从任何地址开始访问，但是事实上不是如此，实际上访问特定类型的变量只能在特定的地址访问，这就需要各个变量在空间上按一定的规则排列，而不是简单地顺序排列，这就是内存对齐。

内存对齐的原因：(1) 某些平台只能在特定的地址处访问特定类型的数据；(2)提高存取数据的速度。

1. 结构体每个成员相对结构体首地址的偏移量(offset)是对齐参数的整数倍，如有需要会在成员之间填充字节。
2. 结构体变量所占空间的大小是对齐参数大小的整数倍。如有需要会在最后一个成员末尾填充若干字节使得所占空间大小是对齐参数大小的整数倍。

```c++
struct Node {
    int a;
    double b;
    float c;
} AA; // 占24个字节

struct Node {
    int a;
    float c;
    double b;
} AA; // 占16个字节

struct Node {
    int a;
    float c;
    double b;
    char arr[17];
} AA; // 占40个字节

struct Node {
    int a;
    float c;
    double b;
    char arr[17];
    static int d; // 静态成员存放在静态数据区，sizeof计算其大小时，不会将空间算进去。(C++中结构体中才能含有静态数据成员，而C中结构体中是不允许含有静态数据成员的)
} AA; // 占40个字节
```

## C++中的强制类型转换和使用场景

四种转换：static_cast、dynamic_cast、const_cast、reinterpert_cast，它们都是类模板。

### static_cast(静态转换)

**使用场景：**

1. 在基本数据类型之间转换，如把 int 转换为 char，这种带来安全性问题由程序员来保证；
2. 在有类型指针与 void * 之间转换；
3. 用于类层次结构中基类和派生类之间指针或引用的转换：上行转换（派生类---->基类）是安全的；下行转换（基类---->派生类）由于没有动态类型检查，所以是不安全的。

**使用特点：**

1. 主要执行非多态的转换操作，用于代替C中通常的转换操作。
2. 隐式转换都建议使用 static_cast 进行标明和替换。
3. 不能使用 static_cast 在有类型指针内转换。

### dynamic_cast(动态转换)

**使用场景：**

用于将一个父类的指针/引用转化为子类的指针/引用（下行转换）。

**使用特点：**

1. 基类必须要有虚函数，因为 dynamic_cast 是运行时类型检查，需要运行时类型信息，而这个信息是存储在类的虚函数表中。
2. 对于下行转换，dynamic_cast 是安全的（当类型不一致时，转换过来的是空指针），而 static_cast 是不安全的。
3. 对指针进行 dynamic_cast，失败返回 NULL，成功返回正常 cast 后的对象指针；对引用进行 dynamic_cast，失败抛出一个异常，成功返回正常 cast 后的对象引用。

### const_cast(常量转换)

**使用场景：**

常量指针（或引用）与非常量指针（或引用）之间的转换。

**使用特点：**

1. cosnt_cast 是四种类型转换符中唯一可以对常量进行操作的转换符。
2. 去除常量性是一个危险的动作，尽量避免使用。

### reinterpret_cast(不相关类型的转换) 

**使用场景：**

1. 用在任意指针（或引用）类型之间的转换。
2. 能够将整型转换为指针，也可以把指针转换为整型或数组。

**使用特点：**

1. reinterpret_cast 是从底层对数据进行重新解释，依赖具体的平台，可移植性差。
2. 不到万不得已，不用使用这个转换符，高危操作。

## 什么是智能指针？怎么实现的？什么时候改变引用计数？

[C++ 智能指针简介](https://blog.csdn.net/K346K346/article/details/53213527)
[c++ 智能指针用法详解](https://www.cnblogs.com/tenosdoit/p/3456704.html)

C++ 中，动态内存的管理是通过一对运算符来完成的，new 用于申请内存空间，调用对象构造函数初始化对象并返回指向该对象的指针。delete接收一个动态对象的指针，调用对象的析构函数销毁对象，释放与之关联的内存空间。动态内存的管理在实际操作中并非易事，因为确保在正确的时间释放内存是极其困难的，有时往往会忘记释放内存而产生内存泄露；有时在上游指针引用内存的情况下释放了内存，就会产生非法的野指针（悬挂指针）。

为了更容易且更安全的管理动态内存，C++ 推出了智能指针（smart pointer）类型来管理动态对象。**智能指针存储指向动态对象的指针，用于动态对象生存周期的控制，能够确保自动正确的销毁动态分配的对象，防止内存泄露。 通俗来讲， 智能指针就是模拟指针动作的类。所有的智能指针都会重载 -> 和 * 操作符。智能指针的主要作用就是用栈智能指针离开作用域自动销毁时调用析构函数来释放资源**。当然，智能指针还不止这些，还包括复制时可以修改源对象等。智能指针根据需求不同，设计也不同（写时复制，赋值即释放对象拥有权限、引用计数、控制权转移等）。

### 什么是引用计数？

智能指针有时需要将其管理的对象的所有权转移给其它的智能指针，使得多个智能指针管理同一个对象，比如C++ STL中的shared_ptr支持多个智能指针管理同一个对象。这个时候智能指针就需要知道其引用的对象总共有多少个智能指针在引用在它，也就是说智能指针所管理的对象总共有多少个所有者，我们称之为引用计数（Reference Counting），因为智能指针在准备释放所引用的对象时，如果有其他的智能指针同时在引用这个对象时，则不能释放，而只能将引用计数减一。

### 引用计数的目的？

引用计数，是资源管理的一种技巧和手段，智能指针使用了引用计数，STL中的string也同样使用了引用计数并配合“写时复制”来实现存储空间的优化。总的来说，使用引用计数有如下两个目的：
（1）节省内存，提高程序运行效率。如何很多对象拥有相同的数据实体，存储多个数据实体会造成内存空间浪费，所以最好做法是让多个对象共享同一个数据实体。
（2）记录引用对象的所有者数量，在引用计数为0时，让对象的最后一个拥有者释放对象。

### 什么时候改变引用计数？

1. 构造函数中计数初始化为1；
2. 拷贝构造函数中计数值加1；
3. 赋值运算符中，左边的对象引用计数减一，右边的对象引用计数加一；
4. 析构函数中引用计数减一；
5. 在赋值运算符和析构函数中，如果减一后为0，则调用delete释放对象。

### 实现

智能指针管理对象，本质上是以栈对象来管理堆对象。智能指针就是一种资源管理对象，提供的功能主要有如下几种：
（1）以指针的行为方式访问所管理的对象，需要重载指针->操作符；
（2）解引用（Dereferencing），获取所管理的对象，需要重载解引用*操作符；
（3）智能指针在其声明周期结束时自动销毁其管理的对象；
（4）引用计数、写时复制、赋值即释放对象拥有权限、控制权限转移。
```c++
template <class T> class SmartPointer {  
private:  
    T *_ptr;  
public:  
    SmartPointer(T *p) : _ptr(p)  //构造函数  
    {  
    }  
    T& operator *()        //重载*操作符  
    {  
        return *_ptr;  
    }  
    T* operator ->()       //重载->操作符  
    {  
        return _ptr;  
    }  
    ~SmartPointer()        //析构函数  
    {  
        delete _ptr;  
    }  
};  
```

## C++中类封装的作用

1. 消除了传统结构方法中数据与操作分离所带来的种种问题，提高了程序的可复用性和可维护性。
2. 把对象的私有数据和公共数据分离开，保护了私有数据，减少了可能的模块间干扰，达到降低程序复杂性、提高可控性的目的。

## C++的多态性

多态性可以简单地概括为“一个接口，多种方法”，程序在运行时才决定调用的函数 。C++多态性主要是通过虚函数实现的 ，虚函数允许子类重写override(注意和overload的区别，overload是重载，是允许同名函数的表现，这些函数参数列表/类型不同）

多态与非多态的实质区别就是函数地址是早绑定还是晚绑定。如果函数的调用，在编译器编译期间就可以确定函数的调用地址，并生产代码，是静态的，就是说地址是早绑定的。而如果函数调用的地址不能在编译器期间确定，需要在运行时才确定，这就属于晚绑定。

在绝大多数情况下，程序的功能是在编译的时候就确定下来的，我们称之为静态特性。反之，如果程序的功能是在运行时刻才能确定下来的，则称之为动态特性。C++中，虚函数，抽象基类，动态绑定和多态构成了出色的动态特性。

最常见的用法就是声明基类的指针，利用该指针指向任意一个子类对象，调用相应的虚函数，可以根据指向的子类的不同而实现不同的方法。

编译时多态性：通过重载函数实现；运行时多态：通过虚函数实现。

## STL中vector的实现原理(衍生：map,unordered_map, set, unordered_set等实现原理)

1. vector是顺序容器，是一个动态数组，支持随机存取、插入、删除、查找等操作，在内存中是一块连续的空间，在原有空间不够的情况下自动分配空间，vector随机存储效率高，但是在vector插入元素，需要移动的数目多，效率低下。
2. map是关联容器，以键值对的形式进行存储，方便进行查找。关键词起到索引的作用，值则表示与索引相关联的数据，低层是以红黑树的结构实现，红黑树的每一个结点都代表着map的一个元素，插入删除等操作都在O(logn)时间内完成，该结构具有自动排序的功能，因此map内部的所有元素都是有序的。unordered_map内部实现了一个哈希表，因此其元素的排列顺序是杂乱的，无序的。因其底层实现是哈希表，所以查找速度非常快。
3. set是关联容器，set中每个元素只包含一个关键字，set支持高效的关键字查询操作，即检查一个给定的关键字是否在set中，set也是以红黑树的结构实现的，支持高校插入、删除等操作。unordered_set: 低层实现也是哈希表。

## 哪些函数不能定义为虚函数？

类的构造函数不能作为虚函数，类的拷贝构造函数也不能作为虚函数，静态成员函数也不能作为虚函数，友元函数也不能作为虚函数。赋值重载函数可以作为虚函数，但是不建议。析构函数可以用作虚函数，并且建议在带有虚函数的类中，最好将基类中的析构函数作为虚函数

# Python相关问题

## 全局解释器锁(GIL)

[谈谈python的GIL、多线程、多进程](https://zhuanlan.zhihu.com/p/20953544)

### 什么是全局解释器锁(GIL)

每个CPU在同一时间只能执行一个线程，那么其他的线程就必须等待该线程的全局解释器的使用权消失后才能使用全局解释器，即使多个线程直接不会相互影响在同一个进程下也只有一个线程使用cpu，这样的机制称为全局解释器锁（GIL）。GIL的设计简化了CPython的实现，使的对象模型包括关键的内建类型，如：字典等，都是隐含的，可以并发访问的，锁住全局解释器使得比较容易的实现对多线程的支持，但也损失了多处理器主机的并行计算能力。

在Python多线程下，每个线程的执行方式：(1)获取GIL；(2)执行代码直到sleep或者是python虚拟机将其挂起；(3)释放GIL。**可见，某个线程想要执行，必须先拿到GIL，我们可以把GIL看作是“通行证”，并且在一个python进程中，GIL只有一个。拿不到通行证的线程，就不允许进入CPU执行**。在python2.x里，GIL的释放逻辑是当前线程遇见IO操作或者ticks计数达到100（ticks可以看作是python自身的一个计数器，专门做用于GIL，每次释放后归零，这个计数可以通过 sys.setcheckinterval 来调整），进行释放，而在python3.x中，GIL不使用ticks计数，改为使用计时器（执行时间达到阈值后，当前线程释放GIL）。每次释放GIL锁，线程进行锁竞争、切换线程，会消耗资源。并且由于GIL锁存在，python里一个进程永远只能同时执行一个线程(拿到GIL的线程才能执行)，这就是为什么在多核CPU上，python的多线程效率并不高。

### 全局解释器锁的好处

1. 避免了大量的加锁解锁的好处
2. 使数据更加安全，

### 全局解释器锁的缺点

多核处理器退化成单核处理器，只能并发不能并行。
**并发**：当有多个进程在操作时，如果系统只有一个CPU，则它根本不可能真正同时执行一个以上的进程，它只能把CPU运行时间划分成若干个时间段，再将时间 段分配给各个进程执行，在一个时间段的进程代码运行时，其它进程处于挂起状，这种方式我们称之为并发。
**并行**：当系统有一个以上CPU时，则进程的操作有可能非并发。当一个CPU执行一个进程时，另一个CPU可以执行另一个进程，两个进程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行。

### GIL的作用

多线程情况下必须存在资源的竞争，GIL是为了保证在解释器级别的线程唯一使用共享资源（CPU）。

### 什么是同步锁

同一时刻的一个进程下的一个线程只能使用一个cpu，要确保这个线程下的程序在一段时间内被cpu执，那么就要用到同步锁。

### 为什么用同步锁

因为有可能当一个线程在使用cpu时，该线程下的程序可能会遇到io操作，那么cpu就会切到别的线程上去，这样就有可能会影响到该程序结果的完整性。

### 怎么使用同步锁

只需要在对公共数据的操作前后加上上锁和释放锁的操作即可。

### 同步锁的作用

为了保证解释器级别下的自己编写的程序唯一使用共享资源产生了同步锁。

### 什么是死锁

指两个或两个以上的线程或进程在执行程序的过程中，因争夺资源或者程序推进顺序不当而相互等待的一个现象。

### 死锁产生的必要条件

互斥条件、请求和保持条件、不剥夺条件、环路等待条件

### 处理死锁的基本方法

预防死锁、避免死锁（银行家算法）、检测死锁（资源分配）、解除死锁：剥夺资源、撤销进程

### 递归锁

在Python中为了支持同一个线程中多次请求同一资源，Python提供了可重入锁。这个RLock内部维护着一个Lock和一个counter变量，counter记录了acquire的次数，从而使得资源可以被多次require。直到一个线程所有的acquire都被release，其他的线程才能获得资源。递归锁分为可递归锁与非递归锁。

### 乐观锁

假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。

### 悲观锁

假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。

## Python多线程的应用场景，对多核处理器的支持？

1. CPU密集型代码(各种循环处理、计数等等)，在这种情况下，ticks计数很快就会达到阈值，然后触发GIL的释放与再竞争（多个线程来回切换当然是需要消耗资源的），所以**python下的多线程对CPU密集型代码并不友好**。
2. IO密集型代码(文件处理、网络爬虫等)，多线程能够有效提升效率(单线程下有IO操作会进行IO等待，造成不必要的时间浪费，而开启多线程能在线程A等待时，自动切换到线程B，可以不浪费CPU的资源，从而能提升程序执行效率)。所以**python的多线程对IO密集型代码比较友好**。
3. 多核多线程比单核多线程更差，原因是单核下多线程，每次释放GIL，唤醒的那个线程都能获取到GIL锁，所以能够无缝执行，但多核下，CPU0释放GIL后，其他CPU上的线程都会进行竞争，但GIL可能会马上又被CPU0拿到，导致其他几个CPU上被唤醒后的线程会醒着等待到切换时间后又进入待调度状态，这样会造成线程颠簸(thrashing)，导致效率更低。

## Python实现多进程的几种方式

进程是python中最小的资源分配单元，也就是**进程中间的数据，内存是不共享的**，每启动一个进程，都要独立分配资源和拷贝访问的数据，子进程里的数据修改无法影响到主进程中的数据，不同子进程之间的数据也不能共享，这是多进程在使用中与多线程最明显的区别。所以进程的启动和销毁的代价是比较大了，所以在实际中使用多进程，要根据服务器的配置来设定。

### 方法一：os.fork()

```python
import os
'''
1.只用在Unix系统中有效，Windows系统中无效
2.fork函数调用一次，返回两次：在父进程中返回值为子进程id，在子进程中返回值为0
'''
pid = os.fork()
if pid == 0:
    print("执行子进程，子进程pid={pid},父进程ppid={ppid}".format(pid=os.getpid(),ppid=os.getppid()))
else:
    print("执行父进程，子进程pid={pid},父进程ppid={ppid}".format(pid=pid,ppid=os.getpid()))
```

### 方法二：使用multiprocessing模块: 创建Process的实例，传入任务执行函数作为参数

```python
"""
Process常用属性与方法：
    name:进程名
    pid：进程id
    run()，自定义子类时覆写
    start()，开启进程
    join(timeout=None)，阻塞进程
    terminate(),终止进程
    is_alive()，判断进程是否存活
"""

import os,time
from multiprocessing import Process

def worker():
    print("子进程执行中>>> pid={0},ppid={1}".format(os.getpid(),os.getppid()))
    time.sleep(2)
    print("子进程终止>>> pid={0}".format(os.getpid()))

def main():
    print("主进程执行中>>> pid={0}".format(os.getpid()))

    ps=[]
    # 创建子进程实例
    for i in range(2):
        p=Process(target=worker,name="worker"+str(i),args=())
        ps.append(p)

    # 开启进程
    for i in range(2):
        ps[i].start()

    # 阻塞进程
    for i in range(2):
        ps[i].join()

    print("主进程终止")

if __name__ == '__main__':
    main()
```

### 方法三：使用multiprocessing模块: 派生Process的子类，重写run方法

```python
import os,time
from multiprocessing import Process

class MyProcess(Process):
    def __init__(self):
        Process.__init__(self)

    def run(self):
        print("子进程开始>>> pid={0},ppid={1}".format(os.getpid(),os.getppid()))
        time.sleep(2)
        print("子进程终止>>> pid={}".format(os.getpid()))

def main():
    print("主进程开始>>> pid={}".format(os.getpid()))
    myp=MyProcess()
    myp.start()
    # myp.join()
    print("主进程终止")

if __name__ == '__main__':
    main()
```

### 方法四：使用进程池Pool

```python
import os,time
from multiprocessing import Pool

def worker(arg):
    print("子进程开始执行>>> pid={},ppid={},编号{}".format(os.getpid(),os.getppid(),arg))
    time.sleep(0.5)
    print("子进程终止>>> pid={},ppid={},编号{}".format(os.getpid(),os.getppid(),arg))

'''
对Pool对象调用join()方法会等待所有子进程执行完毕，调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。
'''

def main():
    print("主进程开始执行>>> pid={}".format(os.getpid()))
    ps=Pool(5)
    for i in range(10):
        # ps.apply(worker,args=(i,))          # 同步执行
        ps.apply_async(worker,args=(i,))  # 异步执行

    # 关闭进程池，停止接受其它进程
    ps.close()
    # 阻塞进程
    ps.join()
    print("主进程终止")

if __name__ == '__main__':
    main()
```

## Python内存管理机制和垃圾回收机制？

[python的内存管理和垃圾回收机制](https://juejin.im/post/5cdb8216e51d456e781f20e0)
[内存管理和垃圾回收机制](https://juejin.im/post/5ca2471df265da307b2d45a3)

Python的内存管理机制有三种：**引用计数、垃圾回收、内存池**

### 引用计数

引用计数是一种非常高效的内存管理手段，当一个pyhton对象被引用时其引用计数增加1，当其不再被引用时引用计数减1，当引用计数等于0的时候，对象就被删除了

### 垃圾回收

Python采用GC作为自动内存管理机制，GC要做的有2件事，一是找到内存中无用的垃圾对象资源，二是清除找到的这些垃圾对象，释放内存给其他对象使用。**Python 采用了引用计数为主， 标志清除和分代回收为辅助的策略**。

**引用计数**：
```c++
typedef struct_object {
 int ob_refcnt;
 struct_typeobject *ob_type;
} PyObject;
```
PyObject是每个对象必有的内容，其中ob_refcnt就是做为引用计数。当一个对象有新的引用时，它的ob_refcnt就会增加，当引用它的对象被删除，它的ob_refcnt就会减少。一旦对象的引用计数为0，该对象立即被回收，对象占用的内存空间将被释放。优点：简单，实时性，一旦没有引用直接释放。缺点：需要额外的空间来维护引用计数，**不能解决对象的循环引用（A引用B，B引用A）问题，会造成内存泄露。为了解决对象循环引用的问题，Python引入了标记清除和分代回收两种GC机制**。

**标记清除**:
标记清除主要用于解决循环引用问题，**主要处理的是容器对象**(list,dict,tuple)。缺点：清除非活动的对象前它必须顺序扫描整个堆内存，哪怕只剩下小部分活动对象也要扫描所有对象。标记清除算法是一种基于追踪回收（tracing GC）技术实现的垃圾回收算法。 它分为两个阶段：第一阶段是标记阶段，GC会把所有的活动对象打上标记，第二阶段是把那些没有标记的对象非活动对象进行回收。对象之间通过引用（指针）连在一起，构成一个有向图，对象构成这个有向图的节点，而引用关系构成这个有向图的边。从根对象（root object）出发，沿着有向边遍历对象，可达的（reachable）对象标记为活动对象，不可达的对象就是要被清除的非活动对象。根对象就是全局变量、调用栈、寄存器。

**分代回收**：
分代回收是一种以空间换时间的操作方式。Python将内存根据对象的存活时间划分为不同的集合，每个集合称为一个代，Python将内存分为了3“代”，分别为年轻代（第0代）、中年代（第1代）、老年代（第2代），他们对应的是3个链表，它们的垃圾收集频率与对象的存活时间的增大而减小。新创建的对象都会分配在年轻代，年轻代链表的总数达到上限时，Python垃圾收集机制就会被触发，把那些可以被回收的对象回收掉，而那些不会回收的对象就会被移到中年代去，依此类推，老年代中的对象是存活时间最久的对象，甚至是存活于整个系统的生命周期内。同时，**分代回收是建立在标记清除技术基础之上**。

## Python中dict的低层是怎么实现的，和list有什么区别，和set呢？

**dict**：CPython使用伪随机探测(pseudo-random probing)的散列表(hash table)作为字典的底层数据结构。由于这个实现细节，**只有可哈希的对象才能作为字典的键**。Python中所有不可变的内置类型都是可哈希的。可变类型（如列表，字典和集合）就是不可哈希的，因此不能作为字典的键。它里面的元素以键值对的形式存在，是无序的，其中键不可以重复，可以通过键来获取键对应的值。
**list**：list底层实现是一种采用分离式技术实现的动态顺序表，可以随着元素的增加和删除而变长和变短，它里面的元素是有顺序的，可以通过索引对其中的元素进行访问。
**set**：可以看成特殊的dict，即都有的值都是一样的，低层实现也是哈希表。set中的元素是不可重复的。

## Python中is和==的区别？

Python中对象（万物皆对象）包含的三个基本要素，分别是：id(身份标识)、type(数据类型)和value(值)。对象之间比较是否相等可以用\==，也可以用is。
is比较的是两个对象的id值是否相等，也就是比较两个对象是否为同一个实例对象，是否指向同一个内存地址。\==比较的是两个对象的内容是否相等，默认会调用对象的__eq__()方法。

## lambda函数

lambda是匿名函数，它可以接收任意多参数，并返回单个表达式的值。**lambda表达式只允许包含一个表达式**，不能包含复杂的语句，**该表达式的运行结果就是函数的返回值**。

## 怎么读取文件更加高效？

如果对于很大的文件，常常不采用`read()`和`readlines()`函数将所有内容读入内存，而是利用`for`循环逐行读取，利用了迭代器，所以它不会一次性将所有文件都载入内存。

## Python迭代器和生成器

**迭代器**：迭代器是遵循迭代协议的对象，是访问容器中元素的一种方式，它可以记住遍历的位置，迭代器有两个基本的方法`iter()`和`next()`，`iter()`返回一个可迭代对象，然后调用`next()`在容器中逐个访问容器元素，当没有后续的元素时，`next()`会抛出一个StopIteration异常。迭代器最大的优势就是延迟计算，按需使用，从而提高开发体验和运行效率。

**生成器**：生成器是一个特殊的程序，可以被用作控制循环的迭代行为，python中生成器是迭代器的一种，使用yield返回值函数，每次调用yield会暂停，而可以使用next()函数和send()函数恢复生成器。生成器类似于返回值为数组的一个函数，这个函数可以接受参数，可以被调用，但是，不同于一般的函数会一次性返回包括了所有数值的数组，**生成器一次只能产生一个值，这样消耗的内存数量将大大减小**，而且允许调用函数可以很快的处理前几个返回值，因此生成器看起来像是一个函数，但是表现得却像是迭代器。

## Python装饰器

装饰器本质上是一个Python函数，它可以让其他函数在不需要做任何代码变动的前提下增加额外功能，装饰器的返回值也是一个函数对象。它经常用于有切面需求的场景，比如：插入日志、性能测试、事务处理、缓存、权限校验等场景。装饰器是解决这类问题的绝佳设计，有了装饰器，我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用。概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能。

```python
# 不带参数的
def log(func):
    def wrapper(*args, **kw):
        print("call",func.__name__)
        return func(*args, **kw)
    return wrapper

@log
def new():
    print("Hello World")

# 带参数的
def log(test):
    def decorator(func):
        def wrapper(*args, **kw):
            print(func.__name__)
        return wrapper
    return decorator

@log("test")
def new():
    print("Hello World")
```

## Python的深拷贝与浅拷贝？

**直接赋值**：其实就是对象的引用(别名)；
修改不可变对象（str、tuple）需要开辟新的空间，修改可变对象（list等）不需要开辟新的空间；

**浅拷贝**：拷贝父对象，不会拷贝对象内部的对象；浅拷贝是在另一块地址中创建一个新的变量或容器，但是容器内的元素的地址均是源对象的元素的地址的拷贝。也就是说新的容器中指向了旧的元素

**深拷贝**：copy模块中的deepcopy方法，完全拷贝了父对象及其子对象。深拷贝是在另一块地址中创建一个新的变量或容器，同时容器内的元素的地址也是新开辟的，仅仅是值相同而已，是完全的副本。

```python
# 浅拷贝
In [13]: a = {1: [1, 2, 3]}

In [14]: b = a.copy() # 浅拷贝

In [15]: a, b
Out[15]: ({1: [1, 2, 3]}, {1: [1, 2, 3]})

In [16]: a[1].append(5)

In [17]: a, b
Out[17]: ({1: [1, 2, 3, 5]}, {1: [1, 2, 3, 5]})


## 深拷贝
In [8]: import copy

In [9]: c = copy.deepcopy(a) # 深拷贝

In [10]: a, c
Out[10]: ({1: [1, 2, 3, 5]}, {1: [1, 2, 3, 5]})

In [11]: a[1].append(6)

In [12]: a, c
Out[12]: ({1: [1, 2, 3, 5, 6]}, {1: [1, 2, 3, 5]})
```

## Python的元组和列表的区别？

元组和列表都是容器对象，都是序列，可以存储任何数据类型，可以通过索引访问。元组是不可变类型，定义一个元组之后就无法再添加和修改元组中的元素，元组是只读的，可以像列表一样读取元组中的元素；列表是可变类型，列表可以实现添加、删除、插入、读取等操作，可以修改列表中的值。

## Python可变类型和不可变类型

1. 可变数据结构：list，dict，set；不可变数据结构：int，str，float，tuple。
2. 当进行修改操作时，可变类型传递的是内存中的地址，也就是说，直接修改内存中的值，并没有开辟新的内存。
3. 不可变类型被改变时，并没有改变原内存地址中的值，而是开辟一块新的内存，将原地址中的值复制过去，对这块新开辟的内存中的值进行操作。

## Python中*args和**kwargs参数是什么意思，Python中参数的位置顺序？

\*args表示该位置是一个可变的位置参数，当我们不确定往一个函数中传入多少参数，或者希望以元组或列表的形式传参数的时候，我们可以使用*args来收集参数。\*\*表示该位置是一个可变的关键词参数，如果我们不知道往函数中传递多少个关键词参数，或者想传入字典的值作为关键词参数的时候我们可以使用**kwargs收集参数。

参数定义的顺序必须是：**必选参数、默认参数、可变参数，命名关键字参数和关键字参数。**

## Python中\_\_new\_\_ 和\_\_init\_\_的区别

1. \_\_new\_\_是用来创造一个类的实例的，而\_\_init\_\_是用来初始化一个实例的。
2. \_\_new\_\_和\_\_init\_\_的参数不同，\_\_new\_\_所接收的第一个参数是cls，而\_\_init\_\_接收的第一个参数是self，\_\_new\_\_创建一个该类的对象并返回，\_\_init__用来初始化该对象。
3. 如果\_\_new\_\_函数中不返回任何对象，则\_\_init\_\_函数也不会被调用。
4. \_\_init\_\_不能有返回值，只有在\_\_new\_\_返回一个属于该类的实例的时候当前类的\_\_init\_\_才会被调用，如果\_\_new\_\_返回的是一个已经存在的实例，则\_\_init\_\_不会被调用。

## Python中的单下划线和双下划线分别是什么？

1. _XXX：不能用`from module import *`导入。“单下划线”开始的成员变量叫做保护变量，意思是只有类对象和子类对象自己能访问到这些变量；
2. \_\_XXX__：系统定义名字
3. __XXX：类中私有变量名。“双下划线” 开始的是私有成员，意思是只有类对象自己能访问，连子类对象也不能访问到这个数据。

## Python中的闭包

闭包：在一个外函数中定义了一个内函数，内函数里运用了外函数的临时变量，并且外函数的返回值是内函数的引用。这样就构成了一个闭包。

```python
def outer(a):
    b = 10
    def inner():
        print(a + b)
    return inner

# 如果要在内函数中修改不可变数据类型，则需要用nonlocal关键字声明
# 或者可以使用可变数据类型，如列表
def outer(a):
    # b = 10
    b = [10]
    def inner():
        # nonlocal b
        b[0] += 1
        print(a + b[0])
    return inner
    
if __name__ == "__main__":
    demo = outer(5)
    demo() # 15
```